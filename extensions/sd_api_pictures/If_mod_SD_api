#This script has been modified by a caveman's monkey all credits to the original author

import base64
import io
import re
from pathlib import Path


import gradio as gr
import modules.chat as chat
import modules.shared as shared

import requests
import torch
from PIL import Image





torch._C._jit_set_profiling_mode(False)

# parameters which can be customized in settings.json of webui  
params = {
    'enable_SD_api': False,
    'address': 'http://127.0.0.1:7860',
    'save_img': False,
    'SD_model': 'NeverEndingDream', # not really used right now
    'prompt_prefix': '(Masterpiece:1.1), (solo:1.3), detailed, intricate, colorful',
    'negative_prompt': '(worst quality, low quality:1.3)',
    #'side_length': 512,
    'width': 576,
    'height': 896,
    'restore_faces': False,
    'enable_hr': True,
    'denoising_strength': 0.33,
    'hr_second_pass_steps': 12,
    'hr_scale': 2,
    'steps': 32,
    'cfg_scale': 7,
    'sampler_index': "UniPC",
    'hr_upscaler': "4x_NMKD-Superscale-SP_178000_G",
    'batch_size': 1,
    'sd_model_checkpoint': "Anything-V3.0-pruned.ckpt [2700c435]"


}
def get_api_list(api_url, format_func):
    response = requests.get(api_url)
    if response.status_code == 200:
        json_data = response.json()
        return [format_func(item) for item in json_data]
    else:
        print(f"Error fetching data from API: {response.status_code}")
        return []

def format_model_name_and_hash(item):
    return f"{item['model_name']} {item['hash']}"

    
samplers_url = "http://localhost:7860" + "/sdapi/v1/samplers"
SD_models_url = "http://localhost:7860" + "/sdapi/v1/sd-models"
upscalers_url = "http://localhost:7860" +"/sdapi/v1/upscalers"


samplers = get_api_list(samplers_url, lambda item: item["name"])
SD_models = get_api_list(SD_models_url, format_model_name_and_hash)
upscalers = get_api_list(upscalers_url, lambda item: item["name"])





streaming_state = shared.args.no_stream # remember if chat streaming was enabled
picture_response = False # specifies if the next model response should appear as a picture
pic_id = 0

def remove_surrounded_chars(string):
    # this expression matches to 'as few symbols as possible (0 upwards) between any asterisks' OR
    # 'as few symbols as possible (0 upwards) between an asterisk and the end of the string'
    return re.sub('\*[^\*]*?(\*|$)','',string)

# I don't even need input_hijack for this as visible text will be commited to history as the unmodified string
def input_modifier(string):
    """
    This function is applied to your text inputs before
    they are fed into the model.
    """
    global params, picture_response
    if not params['enable_SD_api']:
        return string

    commands = ['send', 'mail', 'me']
    mediums = ['image', 'pic', 'picture', 'photo']
    subjects = ['yourself', 'own']
    lowstr = string.lower()

    # TODO: refactor out to separate handler and also replace detection with a regexp
    if any(command in lowstr for command in commands) and any(case in lowstr for case in mediums): # trigger the generation if a command signature and a medium signature is found
        picture_response = True
        shared.args.no_stream = True                                                               # Disable streaming cause otherwise the SD-generated picture would return as a dud
        shared.processing_message = "*Is sending a picture...*"
        string = "Please provide a detailed description of your surroundings, how you look and the situation you're in and what you are doing right now"
        if any(target in lowstr for target in subjects):                                           # the focus of the image should be on the sending character
            string = "Please provide a detailed and vivid description of how you look and what you are wearing"

    return string

# Get and save the Stable Diffusion-generated picture
def get_SD_pictures(description):

    global params, pic_id

    payload = {
        "width": params['width'],
        "height": params['height'],
        "enable_hr": params['enable_hr'],
        "restore_faces": params['restore_faces'],
        "denoising_strength": params['denoising_strength'],
        "hr_second_pass_steps": params['hr_second_pass_steps'],
        "hr_scale": params['hr_scale'],
        "prompt": params['prompt_prefix'] + description,
        "seed": -1,
        "sampler_index": params['sampler_index'],
        "steps": params['steps'],
        "cfg_scale": params['cfg_scale'],
        "negative_prompt": params['negative_prompt'],
        "hr_upscaler": params['hr_upscaler'],
        "batch_size": params['batch_size'],
        "sd_model_checkpoint": params['sd_model_checkpoint']

    }
    
    response = requests.post(url=f'{params["address"]}/sdapi/v1/txt2img', json=payload)
    r = response.json()

    visible_result = ""
    for img_str in r['images']:
        image = Image.open(io.BytesIO(base64.b64decode(img_str.split(",",1)[0])))
        if params['save_img']:
            output_file = Path(f'extensions/sd_api_pictures/outputs/{pic_id:06d}.png')
            image.save(output_file.as_posix())
            pic_id += 1
        # lower the resolution of received images for the chat, otherwise the log size gets out of control quickly with all the base64 values in visible history
        image.thumbnail((300, 300))
        buffered = io.BytesIO()
        image.save(buffered, format="JPEG")
        buffered.seek(0)
        image_bytes = buffered.getvalue()
        img_str = "data:image/jpeg;base64," + base64.b64encode(image_bytes).decode()
        visible_result = visible_result + f'<img src="{img_str}" alt="{description}">\n'
    
    return visible_result

# TODO: how do I make the UI history ignore the resulting pictures (I don't want HTML to appear in history)
# and replace it with 'text' for the purposes of logging?
def output_modifier(string):
    """
    This function is applied to the model outputs.
    """
    global pic_id, picture_response, streaming_state

    if not picture_response:
        return string

    string = remove_surrounded_chars(string)
    string = string.replace('"', '')
    string = string.replace('â€œ', '')
    string = string.replace('\n', ' ')
    string = string.strip()

    if string == '':
        string = 'no viable description in reply, try regenerating'

    # I can't for the love of all that's holy get the name from shared.gradio['name1'], so for now it will be like this
    # I had the fkn same problem but I am near
    text = f'*Description: "{string}"*'

    image = get_SD_pictures(string)

    picture_response = False

    shared.processing_message = "*Is typing...*"
    shared.args.no_stream = streaming_state
    return image + "\n" + text

def bot_prefix_modifier(string):
    """
    This function is only applied in chat mode. It modifies
    the prefix text for the Bot and can be used to bias its
    behavior.
    """

    return string

def force_pic():
    global picture_response
    picture_response = True

def ui():
    global hr_upscaler

    with gr.Accordion("Stable Diffusion api integration", open=True):
        with gr.Row():
            with gr.Column():
                enable = gr.Checkbox(value=params['enable_SD_api'], label='Activate SD Api integration')
                save_img = gr.Checkbox(value=params['save_img'], label='Keep original received images in the outputs subdir')
                address = gr.Textbox(placeholder=params['address'], value=params['address'], label='Stable Diffusion host address')
                steps = gr.Slider(0, 100, value=params['steps'], step=1, label='Steps')
                cfg_scale = gr.Slider(0, 30, value=params['cfg_scale'], step=0.5, label='CFG_scale')
                #sampler_index = gr.Dropdown(label="sampler", choices=['DPM++ SDE Karras','Euler a','Euler','LMS','Heun','DPM2','DPM2 a','DPM++ a', 'DPM++ 2M', 'DPM++ SDE', 'DPM fast', 'DPM adaptive', 'LMS Karras', 'DPM2 Karras', 'DPM2 a Karras', 'DPM++ 2S a Karras', 'DPM++ 2M Karras', 'DPM++ SDE Karras', 'DDIM', 'PLMS', 'UniPC'])
                sampler_index = gr.Dropdown(label="sampler", choices=samplers)
                sd_model_checkpoint = gr.Dropdown(label="model", choices=SD_models)


                
            with gr.Column():
                restore_faces = gr.Checkbox(value=params['restore_faces'], label='Restore faces')
                enable_hr = gr.Checkbox(value=params['enable_hr'], label='Enable High Resolution')
                hr_upscaler = gr.Dropdown(label="model", choices=upscalers)
                denoising_strength = gr.Slider(0, 1, value=params['denoising_strength'], step=0.1, label='Denoising strength')
                batch_size = gr.Slider(1, 6, value=params['batch_size'], step=1, label='batch size')
                hr_second_pass_steps = gr.Slider(0, 30, value=params['hr_second_pass_steps'], step=1, label='HR second pass steps')
                hr_scale = gr.Slider(0, 4, value=params['hr_scale'], step=0.5, label='HR scale')


        with gr.Accordion("Generation parameters", open=False):
            prompt_prefix = gr.Textbox(placeholder=params['prompt_prefix'], value=params['prompt_prefix'], label='Prompt Prefix (best used to describe the look of the character)')
            with gr.Row():
                negative_prompt = gr.Textbox(placeholder=params['negative_prompt'], value=params['negative_prompt'], label='Negative Prompt')
                width = gr.Slider(256, 1024, value=params['width'], step=64, label='Image width')
                height = gr.Slider(256, 1024, value=params['height'], step=64, label='Image height')
    


    
        # Event functions to update the parameters in the backend
        with gr.Row():
            force_btn = gr.Button("Force the next response to be a picture")
            generate_now_btn = gr.Button("Generate an image response to the input")
        


        # Event functions to update the parameters in the backend
        sampler_index.change(lambda x: params.update({"sampler_index": x}), sampler_index, None)

        sd_model_checkpoint.change(lambda x: params.update({"sd_model_checkpoint": x}), sd_model_checkpoint, None)

        batch_size.change(lambda x: params.update({"batch_size": x}), batch_size, None)
        hr_upscaler.change(lambda x: params.update({"hr_upscaler": x}), hr_upscaler, None)
        enable.change(lambda x: params.update({"enable_SD_api": x}), enable, None)
        save_img.change(lambda x: params.update({"save_img": x}), save_img, None)
        address.change(lambda x: params.update({"address": x}), address, None)
        steps.change(lambda x: params.update({"steps": x}), steps, None)
        cfg_scale.change(lambda x: params.update({"cfg_scale": x}), cfg_scale, None)
        restore_faces.change(lambda x: params.update({"restore_faces": x}), restore_faces, None)
        enable_hr.change(lambda x: params.update({"enable_hr": x}), enable_hr, None)
        denoising_strength.change(lambda x: params.update({"denoising_strength": x}), denoising_strength, None)
        hr_second_pass_steps.change(lambda x: params.update({"hr_second_pass_steps": x}), hr_second_pass_steps, None)
        hr_scale.change(lambda x: params.update({"hr_scale": x}), hr_scale, None)
        width.change(lambda x: params.update({"width": x}), width, None)
        height.change(lambda x: params.update({"height": x}), height, None)
        prompt_prefix.change(lambda x: params.update({"prompt_prefix": x}), prompt_prefix, None)
        negative_prompt.change(lambda x: params.update({"negative_prompt": x}), negative_prompt, None)
        # model.change(lambda x: params.update({"SD_model": x}), model, None)

        force_btn.click(force_pic)
        generate_now_btn.click(force_pic)
        generate_now_btn.click(eval('chat.cai_chatbot_wrapper'), shared.input_params, shared.gradio['display'], show_progress=shared.args.no_stream)
